"""Base interfaces and helpers for backup strategies."""

from __future__ import annotations

import abc
import hashlib
import shutil
from dataclasses import dataclass
from pathlib import Path
from typing import Iterator, Optional

from ..exceptions import StrategyExecutionError


CHUNK_SIZE = 65536


@dataclass
class ArtifactMetadata:
    """Metadata describing the artifact generated by a strategy."""

    path: Path
    filename: str
    size: Optional[int]
    checksum: Optional[str]
    format: str
    content_type: str


class BackupStrategy(abc.ABC):
    """Interface that every backup strategy implementation must follow."""

    def __init__(self, *, artifact_config, paths):
        self._artifact_config = artifact_config
        self._paths = paths
        self._metadata: Optional[ArtifactMetadata] = None

    @abc.abstractmethod
    def prepare(self, drive_folder_id: Optional[str] = None) -> ArtifactMetadata:
        """Execute the strategy and return the resulting artifact metadata."""

    @abc.abstractmethod
    def stream(self) -> Iterator[bytes]:
        """Yield the artifact content in chunks suitable for streaming."""

    @abc.abstractmethod
    def cleanup(self) -> None:
        """Release any resources associated to the prepared artifact."""

    @property
    def artifact_config(self):  # pragma: no cover - accessor for subclasses
        return self._artifact_config

    @property
    def paths(self):  # pragma: no cover - accessor for subclasses
        return self._paths

    @property
    def metadata(self) -> ArtifactMetadata:
        if self._metadata is None:
            raise StrategyExecutionError("Strategy has not been prepared yet")
        return self._metadata

    def _register_metadata(self, path: Path, *, size: Optional[int], checksum: Optional[str]) -> ArtifactMetadata:
        self._metadata = ArtifactMetadata(
            path=path,
            filename=self._artifact_config.filename,
            size=size,
            checksum=checksum,
            format=self._artifact_config.format,
            content_type=self._artifact_config.content_type,
        )
        return self._metadata


class FileBasedStrategy(BackupStrategy):
    """Helper strategy that manages a file artifact stored on disk."""

    def __init__(self, *, artifact_config, paths):
        super().__init__(artifact_config=artifact_config, paths=paths)
        self._artifact_path = Path(paths.artifacts) / artifact_config.filename

    def _ensure_workspace(self) -> None:
        self.paths.workdir.mkdir(parents=True, exist_ok=True)
        self.paths.artifacts.mkdir(parents=True, exist_ok=True)
        if self.paths.temp_dump.parent:
            self.paths.temp_dump.parent.mkdir(parents=True, exist_ok=True)
        if self.paths.temp_dump.exists():
            self.paths.temp_dump.unlink()

    def _move_to_artifact(self, source: Path) -> Path:
        if self._artifact_path.exists():
            if self._artifact_path.is_dir():
                raise StrategyExecutionError(
                    f"Artifact path points to a directory: {self._artifact_path}"
                )
            self._artifact_path.unlink()
        shutil.move(str(source), self._artifact_path)
        return self._artifact_path

    def _compute_checksum(self, path: Path) -> tuple[str, int]:
        digest = hashlib.sha256()
        size = 0
        with path.open("rb") as handle:
            for chunk in iter(lambda: handle.read(CHUNK_SIZE), b""):
                digest.update(chunk)
                size += len(chunk)
        return digest.hexdigest(), size

    def stream(self) -> Iterator[bytes]:
        handle = self._artifact_path.open("rb")
        try:
            for chunk in iter(lambda: handle.read(CHUNK_SIZE), b""):
                if chunk:
                    yield chunk
        finally:
            handle.close()

    def cleanup(self) -> None:
        try:
            self._artifact_path.unlink()
        except FileNotFoundError:
            pass

